```tex
串行GC
串行GC对年轻代使用标记-复制算法，对老年代使用标记-清除-整理算法
单线程，不能并行处理，所以都会触发全线暂停，停止所有应用线程
CPU利用率高，暂停时间长
```

```tex
并行GC
年轻代和老年代的垃圾回收都会触发STW事件
年轻代使用标记-复制算法，对老年代使用标记-清除-整理算法
在GC期间，所有CPU内核都在并行清理垃圾，所以总暂停时间更短；
在两次GC周期的间隔期间，没有GC线程运行，不会消耗任何系统资源
```

```tex
CMS GC
对年轻代采用并行STW方式的标记-复制算法，对老年代主要使用并发标记-清除算法
CMS GC的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段达成目标：
1.不对老年代进行整理，而是使用空闲列表(free-lists)来管理内存空间的回收
2.在标记-清除阶段的大部分的工作和应用线程一起并发执行
默认情况下，CMS使用的并发线程数=CPU核心数的1/4

CMS GC的6个阶段：
阶段1：初始标记
此阶段伴随GC暂停，初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）
阶段2：并发标记
此阶段CMS GC遍历老年代，标记所有的存活对象，从前一阶段标记的根对象开始算起
阶段3：并发预清理
因为前一阶段并发标记与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM会通过Card(卡片)的方式将发生了改变的区域标记为脏区，就是卡片标记
阶段4：最终标记
最终标记阶段是此次GC事件中的第二次STW暂停，
本阶段的目标是完成老年代中所有存活对象的标记，因为之前的预清理阶段是并发执行的，有可能GC线程跟不上应用程序的修改速度。所以需要一次STW暂停来处理各种复杂的情况
通常CMS会尝试在年轻代尽可能空的情况下执行Final Remark阶段，以免连续触发多次STW事件
阶段5：并发清除
阶段6：并发重置
重置CMS算法相关的内部数据，为下一次GC循环做准备

优点：
把整个垃圾回收的过程分成了很多个阶段，其中 大部分阶段都可以用和业务线程并发执行的方式来执行垃圾回收工作
真正需要GC暂停就只有在最开始的初始化标记和第四步的最终标记两个比较短的GC阶段，其他阶段GC线程的执行都是根业务线程并发进行
缺点：
在老年代做垃圾回收的时，标记清除完后没有做整个内存的碎片整理（压缩），内存里会存在很多不连续空间的问题

CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。 
最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC会造成不可预测的暂停时间，特别是堆内存较大的情况下。
```

```tex
G1 GC
G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。
堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的小块堆区域(smaller heap regions)。
每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代。
G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每次只处理一部分内存块。
每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。
垃圾最多的小块会被优先收集。
```



```tex
JVM将堆内存分为年轻代(Young generation)和老年代(Old generation)
年轻代来存放JVM刚分配的Java对象
老年代存放年轻代中经过垃圾回收没有回收掉的对象
年轻代划分为3个内存池，新生代(Eden space)和存活区Survivor1, Survivor2
年轻代中默认比例Eden：S0：S1=8：1：1，同一时间内S0跟S1只会有一个区域被占用

非堆本质上还是堆，只是一般不归GC管理，划分为3个内存池 Metaspace(永久代，方法区)，CCS，Code Cache
非堆上存放的不是代码里创建的对象，主要是元数据和JVM在内部运行的时候所使用的其他数据
Code Cache存放JIT(动态即时编译)编译器编译后的本地机器代码
```

